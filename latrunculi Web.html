<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LATRUNCULI â€” Game of Mercenaries</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Cinzel+Decorative:wght@400;700&family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400;1,500&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0806;
    --bg2: #120e08;
    --bg3: #1c1510;
    --bg4: #241c12;
    --panel: #16100a;
    --border: #3d2e18;
    --gold: #c9a227;
    --gold-light: #e8c96d;
    --gold-dim: #8a6e1a;
    --red: #8b1a1a;
    --red-light: #c0392b;
    --red-bright: #e74c3c;
    --cream: #f0e0b8;
    --cream-dim: #b8a07a;
    --stone-light: #c4a46b;
    --stone-dark: #7a5c2a;
    --stone-mid: #9a7840;
    --text: #e8d5a8;
    --text-dim: #8a7050;
    --white-piece: #e8c96d;
    --black-piece: #8b1a1a;
    --selected: rgba(201,162,39,0.5);
    --legal: rgba(201,162,39,0.25);
    --danger: rgba(139,26,26,0.45);
    --hint-good: rgba(30,120,50,0.35);
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'EB Garamond', serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
    background-image:
      radial-gradient(ellipse at 20% 0%, rgba(139,26,26,0.08) 0%, transparent 50%),
      radial-gradient(ellipse at 80% 100%, rgba(201,162,39,0.06) 0%, transparent 50%);
  }

  /* â”€â”€ HEADER â”€â”€ */
  header {
    width: 100%;
    text-align: center;
    padding: 24px 20px 16px;
    border-bottom: 1px solid var(--border);
    background: linear-gradient(180deg, rgba(201,162,39,0.05) 0%, transparent 100%);
    position: relative;
  }
  header::before {
    content: 'âš”';
    position: absolute;
    left: 40px; top: 50%; transform: translateY(-50%);
    font-size: 28px; opacity: 0.4;
  }
  header::after {
    content: 'âš”';
    position: absolute;
    right: 40px; top: 50%; transform: translateY(-50%) scaleX(-1);
    font-size: 28px; opacity: 0.4;
  }
  .title-main {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(22px, 4vw, 38px);
    font-weight: 700;
    letter-spacing: 0.12em;
    background: linear-gradient(135deg, var(--gold-dim) 0%, var(--gold-light) 45%, var(--gold-dim) 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    line-height: 1;
  }
  .title-sub {
    font-family: 'Cinzel', serif;
    font-size: clamp(10px, 1.5vw, 13px);
    letter-spacing: 0.4em;
    color: var(--text-dim);
    margin-top: 6px;
    text-transform: uppercase;
  }

  /* â”€â”€ MAIN LAYOUT â”€â”€ */
  .app {
    display: flex;
    gap: 24px;
    padding: 24px 20px;
    width: 100%;
    max-width: 1100px;
    align-items: flex-start;
  }

  /* â”€â”€ BOARD AREA â”€â”€ */
  .board-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    flex-shrink: 0;
  }

  .board-container {
    position: relative;
    padding: 10px;
    background: var(--bg2);
    border: 2px solid var(--border);
    box-shadow:
      0 0 0 1px rgba(201,162,39,0.1),
      0 8px 40px rgba(0,0,0,0.8),
      inset 0 0 30px rgba(0,0,0,0.3);
  }

  .board-coords-top {
    display: flex;
    padding-left: 22px;
    margin-bottom: 3px;
  }
  .board-coords-left {
    display: flex;
    flex-direction: column;
    justify-content: space-around;
    margin-right: 3px;
    padding-bottom: 2px;
  }
  .coord-label {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    color: var(--gold-dim);
    opacity: 0.7;
    letter-spacing: 0.05em;
  }
  .coord-col { width: var(--sq); text-align: center; }
  .coord-row { height: var(--sq); display: flex; align-items: center; width: 20px; justify-content: flex-end; padding-right: 4px; }

  .board-container {
    --sq: 68px;
  }

  #board {
    display: grid;
    grid-template-columns: repeat(8, var(--sq));
    grid-template-rows: repeat(8, var(--sq));
    border: 1px solid var(--stone-dark);
    cursor: default;
    position: relative;
  }

  .cell {
    width: var(--sq);
    height: var(--sq);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    cursor: pointer;
    transition: background 0.1s;
  }
  .cell.light { background: var(--stone-light); }
  .cell.dark  { background: var(--stone-dark); }
  .cell:hover:not(.no-hover) { filter: brightness(1.12); }

  .cell.selected { background: var(--selected) !important; box-shadow: inset 0 0 0 3px rgba(201,162,39,0.7); }
  .cell.legal-target::after {
    content: '';
    position: absolute;
    width: 20px; height: 20px;
    border-radius: 50%;
    background: rgba(201,162,39,0.45);
    border: 2px solid rgba(201,162,39,0.6);
    pointer-events: none;
  }
  .cell.legal-target.has-enemy::after {
    width: 90%; height: 90%;
    border-radius: 0;
    background: transparent;
    border: 3px solid rgba(201,162,39,0.6);
  }
  .cell.danger-sq   { background: rgba(139,26,26,0.35) !important; }
  .cell.hint-sq     { background: rgba(30,120,50,0.3) !important; }
  .cell.last-move   { box-shadow: inset 0 0 0 2px rgba(201,162,39,0.4); }
  /* explain mode board highlights */
  .cell.ex-src      { background: rgba(74,130,210,0.45) !important; box-shadow: inset 0 0 0 3px rgba(100,160,255,0.7); }
  .cell.ex-dst      { background: rgba(30,140,60,0.45) !important;  box-shadow: inset 0 0 0 3px rgba(60,200,100,0.7); }
  .cell.ex-cap      { background: rgba(180,30,30,0.5)  !important;  box-shadow: inset 0 0 0 3px rgba(255,60,60,0.7); }
  .cell.ex-alt      { background: rgba(160,100,0,0.35) !important;  box-shadow: inset 0 0 0 2px rgba(220,160,0,0.5); }

  /* history items clickable in explain mode */
  .history-item.explain-clickable { cursor: pointer; transition: background 0.15s; }
  .history-item.explain-clickable:hover { background: rgba(201,162,39,0.08); }
  .history-item.explain-active { background: rgba(74,130,210,0.12) !important; border-left: 2px solid rgba(100,160,255,0.7); }

  /* explain panel header */
  .explain-header {
    font-family: 'Cinzel', serif;
    font-size: 10px;
    letter-spacing: 0.25em;
    color: rgba(100,160,255,0.7);
    text-transform: uppercase;
    margin-bottom: 6px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--border);
  }
  .explain-hint {
    font-size: 12px;
    color: var(--text-dim);
    font-style: italic;
    text-align: center;
    padding: 12px 0;
  }

  /* â”€â”€ PIECES â”€â”€ */
  .piece {
    width: 52px;
    height: 52px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    transition: transform 0.15s, box-shadow 0.15s;
    z-index: 2;
    cursor: pointer;
    user-select: none;
  }
  .piece.white {
    background: radial-gradient(circle at 35% 30%, #f5e090, #c9a227 60%, #8a6e1a);
    box-shadow:
      2px 3px 8px rgba(0,0,0,0.6),
      inset 0 -2px 4px rgba(0,0,0,0.3),
      inset 0 2px 4px rgba(255,255,255,0.2);
    border: 2px solid rgba(201,162,39,0.5);
  }
  .piece.black {
    background: radial-gradient(circle at 35% 30%, #d04040, #8b1a1a 60%, #4a0808);
    box-shadow:
      2px 3px 8px rgba(0,0,0,0.6),
      inset 0 -2px 4px rgba(0,0,0,0.4),
      inset 0 2px 4px rgba(255,100,100,0.15);
    border: 2px solid rgba(139,26,26,0.6);
  }
  .piece.white::after {
    content: '';
    width: 18px; height: 10px;
    border-radius: 50%;
    background: rgba(255,255,255,0.25);
    position: absolute;
    top: 10px; left: 10px;
    transform: rotate(-30deg);
  }
  .piece.black::after {
    content: '';
    width: 18px; height: 10px;
    border-radius: 50%;
    background: rgba(255,150,150,0.15);
    position: absolute;
    top: 10px; left: 10px;
    transform: rotate(-30deg);
  }
  .piece:hover { transform: translateY(-2px); box-shadow: 2px 5px 14px rgba(0,0,0,0.7), inset 0 -2px 4px rgba(0,0,0,0.3); }
  .piece.selected-piece { transform: translateY(-4px) scale(1.08); }

  /* â”€â”€ STATUS BAR â”€â”€ */
  .status-bar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: 8px 12px;
    background: var(--bg3);
    border: 1px solid var(--border);
    font-family: 'Cinzel', serif;
    font-size: 12px;
    letter-spacing: 0.08em;
  }
  .piece-count {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .count-pip {
    display: inline-flex;
    align-items: center;
    gap: 5px;
  }
  .count-disc {
    width: 14px; height: 14px;
    border-radius: 50%;
  }
  .count-disc.w { background: var(--gold); }
  .count-disc.b { background: var(--red-light); }

  .turn-indicator {
    font-size: 13px;
    letter-spacing: 0.06em;
    color: var(--gold-light);
  }

  /* â”€â”€ RIGHT PANEL â”€â”€ */
  .panel {
    flex: 1;
    min-width: 280px;
    max-width: 340px;
    display: flex;
    flex-direction: column;
    gap: 14px;
  }

  .panel-card {
    background: var(--bg2);
    border: 1px solid var(--border);
    padding: 16px;
    position: relative;
  }
  .panel-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
    opacity: 0.5;
  }

  .card-title {
    font-family: 'Cinzel', serif;
    font-size: 11px;
    letter-spacing: 0.3em;
    color: var(--gold-dim);
    text-transform: uppercase;
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
  }

  /* â”€â”€ MODE TABS â”€â”€ */
  .mode-tabs {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
  }
  .mode-btn {
    padding: 7px 4px;
    font-family: 'Cinzel', serif;
    font-size: 9.5px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    background: var(--bg3);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
  }
  .mode-btn:hover { border-color: var(--gold-dim); color: var(--cream-dim); }
  .mode-btn.active {
    background: linear-gradient(180deg, rgba(201,162,39,0.15), rgba(201,162,39,0.05));
    border-color: var(--gold);
    color: var(--gold-light);
    box-shadow: 0 0 8px rgba(201,162,39,0.15);
  }

  /* â”€â”€ DIFFICULTY â”€â”€ */
  .diff-row {
    display: flex;
    gap: 6px;
    align-items: center;
  }
  .diff-label {
    font-family: 'Cinzel', serif;
    font-size: 10px;
    letter-spacing: 0.15em;
    color: var(--text-dim);
    text-transform: uppercase;
    min-width: 60px;
  }
  .diff-btn {
    flex: 1;
    padding: 5px;
    font-family: 'Cinzel', serif;
    font-size: 9px;
    letter-spacing: 0.05em;
    background: var(--bg3);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    text-transform: uppercase;
  }
  .diff-btn:hover { border-color: var(--gold-dim); }
  .diff-btn.active { background: rgba(201,162,39,0.1); border-color: var(--gold); color: var(--gold-light); }

  /* â”€â”€ COACH AREA â”€â”€ */
  .coach-scroll {
    max-height: 220px;
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }
  .coach-msg {
    padding: 8px 10px;
    margin-bottom: 8px;
    font-size: 14px;
    line-height: 1.55;
    border-left: 3px solid var(--border);
    background: var(--bg3);
    animation: fadeSlide 0.3s ease;
  }
  .coach-msg.info  { border-left-color: var(--gold-dim); }
  .coach-msg.warn  { border-left-color: var(--red-light); color: #f0c0b0; }
  .coach-msg.good  { border-left-color: #2e7d32; color: #a8d8a8; }
  .coach-msg.lesson { border-left-color: #4a90d9; color: #b8d4f0; font-style: italic; }

  @keyframes fadeSlide {
    from { opacity: 0; transform: translateX(-8px); }
    to   { opacity: 1; transform: translateX(0); }
  }

  /* â”€â”€ LESSON PANEL â”€â”€ */
  .lesson-steps {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  .lesson-step {
    padding: 8px 10px;
    background: var(--bg3);
    border: 1px solid var(--border);
    font-size: 13px;
    line-height: 1.5;
    cursor: pointer;
    transition: border-color 0.2s;
    position: relative;
    padding-left: 30px;
  }
  .lesson-step:hover { border-color: var(--gold-dim); }
  .lesson-step.active { border-color: var(--gold); background: rgba(201,162,39,0.06); }
  .lesson-step::before {
    content: attr(data-num);
    position: absolute;
    left: 8px; top: 8px;
    font-family: 'Cinzel', serif;
    font-size: 11px;
    color: var(--gold-dim);
  }
  .lesson-title { font-family: 'Cinzel', serif; font-size: 11px; color: var(--gold-light); letter-spacing: 0.05em; margin-bottom: 3px; }
  .lesson-body  { color: var(--cream-dim); font-size: 12.5px; }

  /* â”€â”€ MOVE HISTORY â”€â”€ */
  .history-list {
    max-height: 140px;
    overflow-y: auto;
    font-size: 12.5px;
    font-family: 'EB Garamond', serif;
    color: var(--text-dim);
    scrollbar-width: thin;
    scrollbar-color: var(--border) transparent;
  }
  .history-item {
    display: flex;
    gap: 8px;
    padding: 3px 4px;
    border-bottom: 1px solid rgba(61,46,24,0.4);
  }
  .history-item:last-child { border-bottom: none; }
  .h-num { color: var(--gold-dim); min-width: 24px; font-family: 'Cinzel', serif; font-size: 10px; }
  .h-w { color: #c4a46b; }
  .h-b { color: #c07070; }

  /* â”€â”€ BUTTONS â”€â”€ */
  .btn {
    padding: 9px 18px;
    font-family: 'Cinzel', serif;
    font-size: 11px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    background: transparent;
    border: 1px solid var(--gold-dim);
    color: var(--gold);
    cursor: pointer;
    transition: all 0.2s;
    width: 100%;
    margin-top: 8px;
  }
  .btn:hover {
    background: rgba(201,162,39,0.1);
    border-color: var(--gold);
    box-shadow: 0 0 12px rgba(201,162,39,0.15);
  }
  .btn.danger { border-color: var(--red); color: var(--red-light); }
  .btn.danger:hover { background: rgba(139,26,26,0.15); }

  /* â”€â”€ OVERLAY â”€â”€ */
  .overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 100;
    animation: fadeIn 0.3s;
  }
  .overlay.hidden { display: none; }
  @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  .modal {
    background: var(--bg2);
    border: 1px solid var(--border);
    border-top: 3px solid var(--gold);
    padding: 40px;
    max-width: 500px;
    width: 90%;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0,0,0,0.9);
    animation: slideUp 0.3s;
  }
  @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

  .modal-title {
    font-family: 'Cinzel Decorative', serif;
    font-size: 28px;
    background: linear-gradient(135deg, var(--gold-dim), var(--gold-light), var(--gold-dim));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 8px;
  }
  .modal-sub {
    font-size: 15px;
    color: var(--cream-dim);
    margin-bottom: 24px;
    font-style: italic;
  }
  .modal-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    margin-bottom: 28px;
  }
  .stat-box {
    background: var(--bg3);
    border: 1px solid var(--border);
    padding: 12px;
  }
  .stat-label { font-family: 'Cinzel', serif; font-size: 9px; letter-spacing: 0.2em; color: var(--text-dim); text-transform: uppercase; margin-bottom: 4px; }
  .stat-val { font-size: 22px; color: var(--gold-light); }

  /* â”€â”€ REVIEW â”€â”€ */
  .review-event {
    padding: 8px 10px;
    margin-bottom: 6px;
    background: var(--bg3);
    border-left: 3px solid var(--border);
    font-size: 13px;
  }
  .review-event.blunder { border-left-color: var(--red-light); }
  .review-event.good    { border-left-color: #2e7d32; }
  .review-event.neutral { border-left-color: var(--gold-dim); }

  /* â”€â”€ AI THINKING â”€â”€ */
  .thinking-bar {
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
    animation: slide 1s linear infinite;
    display: none;
  }
  .thinking-bar.active { display: block; }
  @keyframes slide {
    from { background-position: -200px 0; }
    to   { background-position: 200px 0; }
  }

  /* â”€â”€ SIDE INDICATORS â”€â”€ */
  .side-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 6px 10px;
    background: var(--bg3);
    border: 1px solid var(--border);
    font-family: 'Cinzel', serif;
    font-size: 10px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }
  .side-disc { width: 16px; height: 16px; border-radius: 50%; }
  .side-disc.w { background: radial-gradient(circle at 35% 30%, #f5e090, #c9a227); }
  .side-disc.b { background: radial-gradient(circle at 35% 30%, #d04040, #8b1a1a); }
  .side-name { flex: 1; }
  .side-count { color: var(--gold-dim); }

  .sides-row { display: flex; gap: 8px; width: 100%; }
  .sides-row .side-indicator { flex: 1; }
  .side-indicator.active { border-color: var(--gold); box-shadow: 0 0 8px rgba(201,162,39,0.12); }

  /* â”€â”€ PIECE SLIDE ANIMATION â”€â”€ */
  .piece-ghost {
    position: absolute;
    width: 52px; height: 52px;
    border-radius: 50%;
    z-index: 20;
    pointer-events: none;
    transition: transform 0.28s cubic-bezier(0.22, 0.61, 0.36, 1);
  }
  .piece-ghost.white {
    background: radial-gradient(circle at 35% 30%, #f5e090, #c9a227 60%, #8a6e1a);
    box-shadow: 2px 3px 8px rgba(0,0,0,0.6), inset 0 -2px 4px rgba(0,0,0,0.3), inset 0 2px 4px rgba(255,255,255,0.2);
    border: 2px solid rgba(201,162,39,0.5);
  }
  .piece-ghost.black {
    background: radial-gradient(circle at 35% 30%, #d04040, #8b1a1a 60%, #4a0808);
    box-shadow: 2px 3px 8px rgba(0,0,0,0.6), inset 0 -2px 4px rgba(0,0,0,0.4), inset 0 2px 4px rgba(255,100,100,0.15);
    border: 2px solid rgba(139,26,26,0.6);
  }
  .piece-ghost::after {
    content: '';
    width: 18px; height: 10px;
    border-radius: 50%;
    position: absolute;
    top: 10px; left: 10px;
    transform: rotate(-30deg);
  }
  .piece-ghost.white::after { background: rgba(255,255,255,0.25); }
  .piece-ghost.black::after { background: rgba(255,150,150,0.15); }

  /* â”€â”€ CAPTURE BURST PARTICLES â”€â”€ */
  .capture-burst {
    position: absolute;
    width: var(--sq); height: var(--sq);
    pointer-events: none;
    z-index: 15;
  }
  .burst-particle {
    position: absolute;
    width: 6px; height: 6px;
    border-radius: 50%;
    top: 50%; left: 50%;
    animation: burstOut 0.55s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
  }
  .burst-particle.gold  { background: #e8c96d; box-shadow: 0 0 6px #c9a227; }
  .burst-particle.red   { background: #e74c3c; box-shadow: 0 0 6px #8b1a1a; }
  .burst-particle.ember { background: #ff9944; box-shadow: 0 0 4px #cc6600; }
  @keyframes burstOut {
    0%   { transform: translate(-50%,-50%) scale(1); opacity: 1; }
    100% { transform: translate(calc(-50% + var(--bx)), calc(-50% + var(--by))) scale(0); opacity: 0; }
  }

  /* â”€â”€ CAPTURE FLASH â”€â”€ */
  .capture-flash {
    position: absolute;
    inset: 0;
    border-radius: 0;
    pointer-events: none;
    z-index: 14;
    animation: capFlash 0.35s ease-out forwards;
  }
  @keyframes capFlash {
    0%   { background: rgba(255,200,50,0.5); }
    100% { background: transparent; }
  }

  /* â”€â”€ SCREEN SHAKE â”€â”€ */
  .board-shake {
    animation: shakeBoard 0.35s ease-out;
  }
  @keyframes shakeBoard {
    0%, 100% { transform: translate(0,0); }
    15%  { transform: translate(-4px, 2px); }
    30%  { transform: translate(3px, -3px); }
    45%  { transform: translate(-2px, 3px); }
    60%  { transform: translate(3px, -1px); }
    75%  { transform: translate(-1px, 2px); }
  }

  /* â”€â”€ SVG MOVE ARROW â”€â”€ */
  .move-arrow-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
    overflow: visible;
  }
  .move-arrow-svg line {
    stroke-dasharray: 200;
    stroke-dashoffset: 200;
    animation: drawArrow 0.35s ease-out forwards;
  }
  .move-arrow-svg polygon {
    opacity: 0;
    animation: fadeArrowHead 0.15s 0.25s ease-out forwards;
  }
  @keyframes drawArrow {
    to { stroke-dashoffset: 0; }
  }
  @keyframes fadeArrowHead {
    to { opacity: 0.7; }
  }

  /* â”€â”€ CHOOSE SIDE â”€â”€ */
  .side-toggle {
    display: flex;
    gap: 6px;
    align-items: center;
    margin-top: 8px;
  }
  .side-toggle-label {
    font-family: 'Cinzel', serif;
    font-size: 10px;
    letter-spacing: 0.15em;
    color: var(--text-dim);
    text-transform: uppercase;
    min-width: 60px;
  }
  .side-btn {
    flex: 1;
    padding: 5px;
    font-family: 'Cinzel', serif;
    font-size: 9px;
    letter-spacing: 0.05em;
    background: var(--bg3);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    text-transform: uppercase;
  }
  .side-btn:hover { border-color: var(--gold-dim); }
  .side-btn.active { background: rgba(201,162,39,0.1); border-color: var(--gold); color: var(--gold-light); }

  /* â”€â”€ PUZZLE MODE â”€â”€ */
  .puzzle-header {
    font-family: 'Cinzel', serif;
    font-size: 12px;
    color: var(--gold-light);
    letter-spacing: 0.1em;
    margin-bottom: 8px;
  }
  .puzzle-objective {
    font-size: 14px;
    color: var(--cream);
    line-height: 1.5;
    margin-bottom: 10px;
    padding: 8px 10px;
    background: var(--bg3);
    border-left: 3px solid var(--gold-dim);
  }
  .puzzle-nav {
    display: flex;
    gap: 6px;
    margin-top: 8px;
  }
  .puzzle-nav-btn {
    flex: 1;
    padding: 6px;
    font-family: 'Cinzel', serif;
    font-size: 10px;
    background: var(--bg3);
    border: 1px solid var(--border);
    color: var(--text-dim);
    cursor: pointer;
    transition: all 0.2s;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .puzzle-nav-btn:hover { border-color: var(--gold-dim); color: var(--cream-dim); }
  .puzzle-nav-btn:disabled { opacity: 0.35; cursor: default; }
  .puzzle-progress {
    font-family: 'Cinzel', serif;
    font-size: 10px;
    color: var(--text-dim);
    text-align: center;
    margin-top: 6px;
    letter-spacing: 0.1em;
  }
  .puzzle-solved {
    padding: 12px;
    background: rgba(30,120,50,0.12);
    border: 1px solid rgba(46,125,50,0.4);
    text-align: center;
    font-family: 'Cinzel', serif;
    font-size: 13px;
    color: #a8d8a8;
    margin-top: 8px;
    animation: fadeSlide 0.3s ease;
  }

  /* responsive */
  @media (max-width: 820px) {
    .app { flex-direction: column; align-items: center; }
    .panel { max-width: 544px; width: 100%; }
    .board-container { --sq: 58px; }
  }
  @media (max-width: 520px) {
    .board-container { --sq: 44px; }
    .piece { width: 36px; height: 36px; }
    .piece::after { width: 13px; height: 7px; }
    .piece-ghost { width: 36px; height: 36px; }
    .piece-ghost::after { width: 13px; height: 7px; }
  }
</style>
</head>
<body>

<header>
  <div class="title-main">Latrunculi</div>
  <div class="title-sub">Ludus Latrunculorum â€” Game of Mercenaries</div>
</header>

<div class="app">
  <!-- BOARD AREA -->
  <div class="board-area">
    <div class="sides-row">
      <div class="side-indicator" id="ind-black">
        <div class="side-disc b"></div>
        <div class="side-name">Black</div>
        <div class="side-count" id="cnt-black">16</div>
      </div>
      <div class="side-indicator" id="ind-white">
        <div class="side-disc w"></div>
        <div class="side-name">White</div>
        <div class="side-count" id="cnt-white">16</div>
      </div>
    </div>

    <div class="board-container">
      <div class="thinking-bar" id="thinking-bar"></div>
      <div style="display:flex">
        <div class="board-coords-left" id="coords-left"></div>
        <div style="position:relative">
          <div class="board-coords-top" id="coords-top"></div>
          <div id="board" style="position:relative"></div>
          <svg class="move-arrow-svg" id="move-arrow" style="position:absolute;top:0;left:0;pointer-events:none"></svg>
        </div>
      </div>
    </div>

    <div class="turn-indicator" id="turn-indicator">White's Turn</div>
  </div>

  <!-- RIGHT PANEL -->
  <div class="panel">

    <!-- MODE -->
    <div class="panel-card">
      <div class="card-title">Mode</div>
      <div class="mode-tabs" style="grid-template-columns:repeat(3,1fr)">
        <button class="mode-btn active" data-mode="spar"    onclick="setMode('spar')">âš” Spar</button>
        <button class="mode-btn"        data-mode="hint"    onclick="setMode('hint')">ğŸ’¡ Hint</button>
        <button class="mode-btn"        data-mode="learn"   onclick="setMode('learn')">ğŸ“œ Learn</button>
      </div>
      <div class="mode-tabs" style="grid-template-columns:repeat(3,1fr);margin-top:4px">
        <button class="mode-btn"        data-mode="puzzle"  onclick="setMode('puzzle')">ğŸ§© Puzzle</button>
        <button class="mode-btn"        data-mode="explain" onclick="setMode('explain')">ğŸ” Explain</button>
        <button class="mode-btn"        data-mode="review"  onclick="setMode('review')">ğŸ“‹ Review</button>
      </div>
    </div>

    <!-- DIFFICULTY (shown in spar + hint) -->
    <div class="panel-card" id="diff-card">
      <div class="card-title">Difficulty</div>
      <div class="diff-row">
        <span class="diff-label">Depth</span>
        <button class="diff-btn active" data-d="1" onclick="setDepth(1)">Novice</button>
        <button class="diff-btn" data-d="2" onclick="setDepth(2)">Soldier</button>
        <button class="diff-btn" data-d="3" onclick="setDepth(3)">Tribune</button>
        <button class="diff-btn" data-d="4" onclick="setDepth(4)">Praetor</button>
      </div>
      <div class="side-toggle" id="side-toggle">
        <span class="side-toggle-label">Play as</span>
        <button class="side-btn active" data-s="W" onclick="setPlayerSide('W')">White</button>
        <button class="side-btn" data-s="B" onclick="setPlayerSide('B')">Black</button>
      </div>
    </div>

    <!-- COACH -->
    <div class="panel-card" id="coach-card">
      <div class="card-title" id="coach-title">Coach</div>
      <div class="coach-scroll" id="coach-area"></div>
    </div>

    <!-- LESSONS (shown in learn mode) -->
    <div class="panel-card hidden" id="lessons-card">
      <div class="card-title">Lessons</div>
      <div class="lesson-steps" id="lessons-area"></div>
    </div>

    <!-- HISTORY -->
    <div class="panel-card">
      <div class="card-title">Move History</div>
      <div class="history-list" id="history-list"></div>
    </div>

    <!-- PUZZLE PANEL (shown in puzzle mode) -->
    <div class="panel-card hidden" id="puzzle-card">
      <div class="card-title">Puzzle</div>
      <div class="puzzle-header" id="puzzle-title"></div>
      <div class="puzzle-objective" id="puzzle-objective"></div>
      <div id="puzzle-feedback"></div>
      <div class="puzzle-nav">
        <button class="puzzle-nav-btn" id="puzzle-prev" onclick="puzzleNav(-1)">â† Prev</button>
        <button class="puzzle-nav-btn" id="puzzle-reset" onclick="loadPuzzle(currentPuzzle)">Reset</button>
        <button class="puzzle-nav-btn" id="puzzle-next" onclick="puzzleNav(1)">Next â†’</button>
      </div>
      <div class="puzzle-progress" id="puzzle-progress"></div>
    </div>

    <!-- CONTROLS -->
    <div class="panel-card">
      <div class="card-title">Controls</div>
      <button class="btn" onclick="newGame()">New Game</button>
      <button class="btn" onclick="undoMove()" id="undo-btn" style="border-color:var(--stone-mid);color:var(--cream-dim)">Undo Move</button>
      <button class="btn danger" onclick="resign()">Resign</button>
    </div>

  </div>
</div>

<!-- WIN OVERLAY -->
<div class="overlay hidden" id="win-overlay">
  <div class="modal">
    <div class="modal-title" id="win-title">Victory!</div>
    <div class="modal-sub" id="win-sub">The battle is decided.</div>
    <div class="modal-stats">
      <div class="stat-box">
        <div class="stat-label">Turns Played</div>
        <div class="stat-val" id="stat-turns">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Captures</div>
        <div class="stat-val" id="stat-caps">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">White Remaining</div>
        <div class="stat-val" id="stat-w">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Black Remaining</div>
        <div class="stat-val" id="stat-b">0</div>
      </div>
    </div>
    <div id="postgame-review" style="text-align:left;margin-bottom:20px;"></div>
    <button class="btn" onclick="newGame()">Play Again</button>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONSTANTS & TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const EMPTY = '.', WHITE = 'W', BLACK = 'B';
const SIZE  = 8;
const DIRS  = [[1,0],[-1,0],[0,1],[0,-1]];
const FILES = 'abcdefgh';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let state       = null;   // { board: 2d array, toMove: 'W'|'B' }
let selected    = null;   // [r,c] or null
let legalCache  = [];     // legal moves for selected piece
let mode        = 'spar'; // spar | hint | learn | review
let aiDepth     = 1;
let aiSide      = BLACK;
let gameOver    = false;
let history     = [];     // [{move, cap, walkedInDanger, stateBefore}]
let stateHistory= [];     // full GameState snapshots, one per move (state BEFORE move)
let moveNum     = 0;
let totalCaps   = 0;
let reviewLog   = [];     // {turn, type, msg}
let coachMsgs   = [];

function cloneBoard(b) { return b.map(r => [...r]); }

function initialBoard() {
  const b = Array.from({length:SIZE}, () => Array(SIZE).fill(EMPTY));
  // White on rank 2 â†’ row index 6
  for (let c = 0; c < SIZE; c++) { b[6][c] = WHITE; b[1][c] = BLACK; }
  return b;
}

function makeState(board, toMove = WHITE) { return { board, toMove }; }

function inBounds(r,c) { return r>=0 && r<SIZE && c>=0 && c<SIZE; }

function opponent(p) { return p === WHITE ? BLACK : WHITE; }

function countPieces(board, p) {
  let n = 0;
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (board[r][c]===p) n++;
  return n;
}

function legalMoves(st, player) {
  const side = player || st.toMove;
  const moves = [];
  for (let r=0;r<SIZE;r++) {
    for (let c=0;c<SIZE;c++) {
      if (st.board[r][c] !== side) continue;
      for (const [dr,dc] of DIRS) {
        let nr=r+dr, nc=c+dc;
        while (inBounds(nr,nc) && st.board[nr][nc]===EMPTY) {
          moves.push({src:[r,c], dst:[nr,nc]});
          nr+=dr; nc+=dc;
        }
      }
    }
  }
  return moves;
}

function isLegalMove(st, src, dst) {
  const [sr,sc] = src, [dr,dc] = dst;
  if (!inBounds(sr,sc)||!inBounds(dr,dc)) return false;
  if (sr===dr && sc===dc) return false;
  if (st.board[sr][sc] !== st.toMove) return false;
  if (st.board[dr][dc] !== EMPTY) return false;
  if (sr!==dr && sc!==dc) return false;
  const stepR = sr===dr ? 0 : (dr>sr ? 1:-1);
  const stepC = sc===dc ? 0 : (dc>sc ? 1:-1);
  let r=sr+stepR, c=sc+stepC;
  while (r!==dr||c!==dc) {
    if (st.board[r][c]!==EMPTY) return false;
    r+=stepR; c+=stepC;
  }
  return true;
}

function applyMove(st, move) {
  const {src:[sr,sc], dst:[dr,dc]} = move;
  const player = st.toMove;
  const enemy  = opponent(player);
  const board  = cloneBoard(st.board);
  board[sr][sc] = EMPTY;
  board[dr][dc] = player;
  let caps = 0;
  for (const [drow,dcol] of DIRS) {
    const ar=dr+drow, ac=dc+dcol;
    const br=dr+2*drow, bc=dc+2*dcol;
    if (!inBounds(ar,ac)||!inBounds(br,bc)) continue;
    if (board[ar][ac]===enemy && board[br][bc]===player) {
      board[ar][ac]=EMPTY; caps++;
    }
  }
  return { state: makeState(board, enemy), captures: caps };
}

function winner(st) {
  const wc = countPieces(st.board, WHITE);
  const bc = countPieces(st.board, BLACK);
  if (wc===0) return BLACK;
  if (bc===0) return WHITE;
  if (legalMoves(st, st.toMove).length===0) return opponent(st.toMove);
  return null;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  AI ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const TERMINAL_SCORE = 100000;

function bracketing(board, player) {
  // count how many enemy pieces are threatened (1 bracket away)
  const enemy = opponent(player);
  let threats = 0;
  for (let r=0;r<SIZE;r++) {
    for (let c=0;c<SIZE;c++) {
      if (board[r][c]!==enemy) continue;
      for (const [dr,dc] of DIRS) {
        const ar=r-dr, ac=c-dc; // one side
        const br=r+dr, bc=c+dc; // other side
        if (!inBounds(ar,ac)||!inBounds(br,bc)) continue;
        if (board[ar][ac]===player && board[br][bc]===EMPTY) threats++;
        if (board[ar][ac]===EMPTY && board[br][bc]===player) threats++;
      }
    }
  }
  return threats;
}

function trappedPieces(st, player) {
  // pieces with very low mobility
  const moves = legalMoves(st, player);
  const srcSet = {};
  for (const m of moves) srcSet[m.src[0]+','+m.src[1]] = (srcSet[m.src[0]+','+m.src[1]]||0)+1;
  let trapped = 0;
  for (let r=0;r<SIZE;r++)
    for (let c=0;c<SIZE;c++)
      if (st.board[r][c]===player && (srcSet[r+','+c]||0) <= 1) trapped++;
  return trapped;
}

function evaluate(st, perspective) {
  const w = winner(st);
  if (w===perspective)  return  TERMINAL_SCORE;
  if (w===opponent(perspective)) return -TERMINAL_SCORE;

  const myMat  = countPieces(st.board, perspective);
  const oppMat = countPieces(st.board, opponent(perspective));
  const myMob  = legalMoves(st, perspective).length;
  const oppMob = legalMoves(st, opponent(perspective)).length;
  const myBrk  = bracketing(st.board, perspective);
  const oppBrk = bracketing(st.board, opponent(perspective));
  const myTrap = trappedPieces(st, perspective);
  const oppTrap= trappedPieces(st, opponent(perspective));

  return (myMat - oppMat) * 100
       + (myMob - oppMob) * 5
       + (myBrk - oppBrk) * 15
       + (oppTrap - myTrap) * 8;
}

function minimax(st, depth, alpha, beta, maximizing, perspective) {
  if (depth <= 0 || winner(st) !== null) return evaluate(st, perspective);
  const moves = legalMoves(st);
  if (!moves.length) return evaluate(st, perspective);

  if (maximizing) {
    let val = -Infinity;
    for (const m of moves) {
      const {state: ns} = applyMove(st, m);
      val = Math.max(val, minimax(ns, depth-1, alpha, beta, false, perspective));
      alpha = Math.max(alpha, val);
      if (beta <= alpha) break;
    }
    return val;
  } else {
    let val = Infinity;
    for (const m of moves) {
      const {state: ns} = applyMove(st, m);
      val = Math.min(val, minimax(ns, depth-1, alpha, beta, true, perspective));
      beta = Math.min(beta, val);
      if (beta <= alpha) break;
    }
    return val;
  }
}

function chooseMove(st, depth) {
  const moves = legalMoves(st);
  if (!moves.length) return null;
  const perspective = st.toMove;
  let best = moves[0], bestScore = -Infinity;
  for (const m of moves) {
    const {state: ns} = applyMove(st, m);
    const score = minimax(ns, depth-1, -Infinity, Infinity, false, perspective);
    if (score > bestScore) { bestScore = score; best = m; }
  }
  return best;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COACH / ANALYSIS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PRINCIPLES = {
  captureGeometry: "Custodial capture: sandwich an enemy piece on opposite sides orthogonally.",
  dangerSquare:    "A piece is 'hot' if an enemy can bracket it next turn.",
  fork:            "A fork threatens two captures at once â€” devastating if unblocked.",
  tempo:           "Don't rush forward; walking into a bracket costs you tempo and material.",
  gate:            "Two pieces forming a gate restrict enemy escape routes.",
  endgame:         "In the endgame, reduce mobility first â€” herd, then capture.",
};

function getDangerSquares(st, player) {
  // squares where player's pieces are threatened by a 1-move capture
  const enemy = opponent(player);
  const enemyMoves = legalMoves(st, enemy);
  const dangerous = new Set();
  for (const m of enemyMoves) {
    const {state: ns} = applyMove({...st, toMove: enemy}, m);
    // find pieces player lost
    for (let r=0;r<SIZE;r++) {
      for (let c=0;c<SIZE;c++) {
        if (st.board[r][c]===player && ns.board[r][c]!==player) {
          dangerous.add(r+','+c);
        }
      }
    }
  }
  return dangerous;
}

function getForkMoves(st) {
  // moves that cause 2+ captures
  const forks = [];
  for (const m of legalMoves(st)) {
    const {state: ns, captures} = applyMove(st, m);
    if (captures >= 2) forks.push({move: m, captures});
  }
  return forks;
}

function getBracketingMoves(st) {
  // moves that create a capture (1+)
  const caps = [];
  for (const m of legalMoves(st)) {
    const {captures} = applyMove(st, m);
    if (captures >= 1) caps.push({move: m, captures});
  }
  return caps;
}

function analyzeHint(st, proposedSrc, proposedDst) {
  // Is the proposed move walking into danger?
  if (!proposedSrc || !proposedDst) return null;
  if (!isLegalMove(st, proposedSrc, proposedDst)) return null;

  const {state: ns} = applyMove(st, {src: proposedSrc, dst: proposedDst});
  const dangerAfter = getDangerSquares(ns, st.toMove);
  if (dangerAfter.has(proposedDst[0]+','+proposedDst[1])) {
    return { type:'warn', text: `âš  Caution: moving to ${formatCoord(proposedDst)} places your piece in immediate danger of being captured next turn. ${PRINCIPLES.dangerSquare}` };
  }
  // Does it capture?
  const {captures} = applyMove(st, {src: proposedSrc, dst: proposedDst});
  if (captures >= 2) return { type:'good', text: `âœ¦ Excellent! This move captures ${captures} enemy pieces â€” a fork! ${PRINCIPLES.fork}` };
  if (captures === 1) return { type:'good', text: `âœ¦ This move captures 1 enemy piece through custodial sandwich. ${PRINCIPLES.captureGeometry}` };
  return null;
}

function coachTurnAnalysis(st) {
  const msgs = [];
  const side = st.toMove;

  // Check for available forks
  const forks = getForkMoves(st);
  if (forks.length) {
    const m = forks[0].move;
    msgs.push({type:'good', text: `Fork available! ${formatCoord(m.src)} â†’ ${formatCoord(m.dst)} captures ${forks[0].captures} pieces. ${PRINCIPLES.fork}`});
  }

  // Check capturing moves
  const caps = getBracketingMoves(st);
  if (!forks.length && caps.length) {
    const m = caps[0].move;
    msgs.push({type:'info', text: `Capture opportunity: ${formatCoord(m.src)} â†’ ${formatCoord(m.dst)}.`});
  }

  // Danger squares for current player
  const danger = getDangerSquares(st, side);
  if (danger.size) {
    const coordStr = [...danger].map(k => { const [r,c] = k.split(','); return formatCoord([+r,+c]); }).join(', ');
    msgs.push({type:'warn', text: `âš  Pieces at ${coordStr} are in danger of being captured!`});
  }

  return msgs;
}

function generateReview(histArr) {
  // Identify turning points from move history
  const events = [];
  for (let i=0; i<histArr.length; i++) {
    const h = histArr[i];
    if (h.captures >= 2) events.push({type:'good', turn:i+1, msg:`Turn ${i+1}: ${h.player===WHITE?'White':'Black'} executed a fork capturing ${h.captures} pieces.`});
    else if (h.captures === 1) events.push({type:'neutral', turn:i+1, msg:`Turn ${i+1}: ${h.player===WHITE?'White':'Black'} made a custodial capture.`});
    if (h.walkedInDanger) events.push({type:'blunder', turn:i+1, msg:`Turn ${i+1}: ${h.player===WHITE?'White':'Black'} walked a piece into danger (hung piece).`});
  }
  return events.slice(-6); // last 6 notable events
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  COORD UTILS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function formatCoord([r,c]) { return FILES[c]+(SIZE-r); }
function parseCoord(s) { return [SIZE-parseInt(s[1]), FILES.indexOf(s[0])]; }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function buildBoard() {
  const boardEl = document.getElementById('board');
  const topEl   = document.getElementById('coords-top');
  const leftEl  = document.getElementById('coords-left');

  // top coords
  topEl.innerHTML = '';
  for (let c=0;c<SIZE;c++) {
    const d = document.createElement('div');
    d.className='coord-label coord-col';
    d.textContent = FILES[c];
    topEl.appendChild(d);
  }
  // left coords
  leftEl.innerHTML = '';
  for (let r=0;r<SIZE;r++) {
    const d = document.createElement('div');
    d.className='coord-label coord-row';
    d.textContent = SIZE-r;
    leftEl.appendChild(d);
  }

  boardEl.innerHTML = '';
  for (let r=0;r<SIZE;r++) {
    for (let c=0;c<SIZE;c++) {
      const cell = document.createElement('div');
      cell.className = 'cell ' + ((r+c)%2===0 ? 'light':'dark');
      cell.id = `cell-${r}-${c}`;
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.addEventListener('click', () => onCellClick(r,c));
      boardEl.appendChild(cell);
    }
  }
}

let dangerHighlights = new Set();

function renderState() {
  if (!state) return;
  const board = state.board;

  // Compute dangers for hint mode
  dangerHighlights = (mode==='hint') ? getDangerSquares(state, state.toMove) : new Set();

  for (let r=0;r<SIZE;r++) {
    for (let c=0;c<SIZE;c++) {
      const cell = document.getElementById(`cell-${r}-${c}`);
      // reset classes
      cell.className = 'cell ' + ((r+c)%2===0 ? 'light':'dark');
      cell.innerHTML = '';

      // highlights
      if (selected && selected[0]===r && selected[1]===c) {
        cell.classList.add('selected');
      }
      if (dangerHighlights.has(r+','+c)) {
        cell.classList.add('danger-sq');
      }
      // last move highlight
      if (history.length > 0 && mode !== 'explain') {
        const last = history[history.length - 1];
        if ((last.src[0]===r && last.src[1]===c) || (last.dst[0]===r && last.dst[1]===c)) {
          cell.classList.add('last-move');
        }
      }

      // legal targets
      const isTarget = legalCache.some(m => m.dst[0]===r && m.dst[1]===c);
      if (isTarget) {
        cell.classList.add('legal-target');
        if (board[r][c]!==EMPTY) cell.classList.add('has-enemy');
      }

      // piece
      if (board[r][c]!==EMPTY) {
        const pc = document.createElement('div');
        pc.className = 'piece ' + (board[r][c]===WHITE ? 'white':'black');
        if (selected && selected[0]===r && selected[1]===c) pc.classList.add('selected-piece');
        cell.appendChild(pc);
      }
    }
  }

  // update counts
  const wc = countPieces(board, WHITE);
  const bc = countPieces(board, BLACK);
  document.getElementById('cnt-white').textContent = wc;
  document.getElementById('cnt-black').textContent = bc;

  // turn
  const isAITurn = state.toMove === aiSide && mode !== 'review';
  document.getElementById('turn-indicator').textContent =
    gameOver ? 'Game Over' :
    (isAITurn ? 'âš™ AI is thinkingâ€¦' : (state.toMove===WHITE ? "White's Turn" : "Black's Turn"));

  // side indicators
  document.getElementById('ind-white').className = 'side-indicator' + (state.toMove===WHITE&&!gameOver?' active':'');
  document.getElementById('ind-black').className = 'side-indicator' + (state.toMove===BLACK&&!gameOver?' active':'');
}

function addCoachMsg(msg) {
  const area = document.getElementById('coach-area');
  const div = document.createElement('div');
  div.className = `coach-msg ${msg.type}`;
  div.textContent = msg.text;
  area.appendChild(div);
  area.scrollTop = area.scrollHeight;
}

function clearCoach() {
  document.getElementById('coach-area').innerHTML = '';
}

function addHistory(player, src, dst, caps) {
  const idx = history.length - 1;
  addHistoryEntry(player, src, dst, caps, idx);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPLAIN MODE ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let explainActive = null; // index of currently explained move

function refreshHistoryClickable() {
  document.querySelectorAll('.history-item').forEach(row => {
    if (mode === 'explain') row.classList.add('explain-clickable');
    else row.classList.remove('explain-clickable', 'explain-active');
  });
}

function onHistoryClick(idx, rowEl) {
  if (mode !== 'explain') return;
  explainActive = idx;
  // mark active row
  document.querySelectorAll('.history-item').forEach(r => r.classList.remove('explain-active'));
  rowEl.classList.add('explain-active');
  explainMove(idx);
}

function showExplainBoard(h) {
  // Temporarily overlay the board with the position BEFORE the move
  // highlighting src (blue), dst (green), captured squares (red)
  const sb = h.stateBefore;
  const {state: ns} = applyMove(sb, {src: h.src, dst: h.dst});

  // find captured squares: were enemy, now empty
  const enemy = opponent(h.player);
  const capSquares = [];
  for (let r=0;r<SIZE;r++)
    for (let c=0;c<SIZE;c++)
      if (sb.board[r][c]===enemy && ns.board[r][c]===EMPTY)
        capSquares.push([r,c]);

  // Clear all explain highlights first
  document.querySelectorAll('.cell').forEach(el => {
    el.classList.remove('ex-src','ex-dst','ex-cap','ex-alt','selected','legal-target');
    el.innerHTML = '';
  });

  // Draw the BEFORE position
  for (let r=0;r<SIZE;r++) {
    for (let c=0;c<SIZE;c++) {
      const cell = document.getElementById(`cell-${r}-${c}`);
      if (sb.board[r][c] !== EMPTY) {
        const pc = document.createElement('div');
        pc.className = 'piece ' + (sb.board[r][c]===WHITE?'white':'black');
        cell.appendChild(pc);
      }
    }
  }

  // Apply highlights
  const [sr,sc] = h.src, [dr,dc] = h.dst;
  document.getElementById(`cell-${sr}-${sc}`).classList.add('ex-src');
  document.getElementById(`cell-${dr}-${dc}`).classList.add('ex-dst');
  capSquares.forEach(([r,c]) => document.getElementById(`cell-${r}-${c}`).classList.add('ex-cap'));
}

function explainMove(idx) {
  if (idx < 0 || idx >= history.length) return;
  const h = history[idx];
  const sb = h.stateBefore; // GameState before the move

  clearCoach();
  showExplainBoard(h);

  const pName  = h.player === WHITE ? 'White' : 'Black';
  const srcStr = formatCoord(h.src);
  const dstStr = formatCoord(h.dst);
  const turnNum = idx + 1;

  // â”€â”€ WHAT HAPPENED â”€â”€
  addCoachMsg({type:'info', text: `Turn ${turnNum} â€” ${pName}: ${srcStr} â†’ ${dstStr}${h.captures ? ` (captured ${h.captures} piece${h.captures>1?'s':''})` : ''}`});

  // â”€â”€ CAPTURE EXPLANATION â”€â”€
  if (h.captures >= 2) {
    addCoachMsg({type:'good', text:`âš” FORK! This move captured ${h.captures} pieces simultaneously by landing between two enemy clusters. This is one of the most powerful moves in Latrunculi â€” your opponent could only block one threat.`});
  } else if (h.captures === 1) {
    // Find which direction the capture came from
    const [dr,dc] = h.dst;
    let capDir = '';
    for (const [drow,dcol] of DIRS) {
      const ar=dr+drow, ac=dc+dcol;
      const br=dr+2*drow, bc=dc+2*dcol;
      if (!inBounds(ar,ac)||!inBounds(br,bc)) continue;
      if (sb.board[ar][ac]===opponent(h.player) && sb.board[br][bc]===h.player) {
        capDir = drow!==0 ? (drow>0?'south':'north') : (dcol>0?'east':'west');
        addCoachMsg({type:'good', text:`âœ¦ Custodial capture to the ${capDir}: the piece at ${formatCoord([ar,ac])} was sandwiched between ${dstStr} and the anchor at ${formatCoord([br,bc])}. Classic bracket geometry.`});
        break;
      }
    }
  }

  // â”€â”€ DANGER / BLUNDER â”€â”€
  if (h.walkedInDanger) {
    addCoachMsg({type:'warn', text:`âš  HUNG PIECE: After this move, the piece at ${dstStr} could be captured by the opponent next turn. Moving into a bracket zone without a retreat is one of the most common beginner mistakes. Always check if the destination can be sandwiched before committing.`});

    // Suggest what AI would have played instead
    const aiMove = chooseMove(sb, Math.min(aiDepth+1, 3));
    if (aiMove && !(aiMove.src[0]===h.src[0] && aiMove.src[1]===h.src[1] && aiMove.dst[0]===h.dst[0] && aiMove.dst[1]===h.dst[1])) {
      addCoachMsg({type:'lesson', text:`ğŸ’¡ The engine preferred ${formatCoord(aiMove.src)} â†’ ${formatCoord(aiMove.dst)} instead â€” safer destination with more escape routes.`});
      // Highlight alt move on board
      const [ar,ac] = aiMove.dst;
      document.getElementById(`cell-${ar}-${ac}`).classList.add('ex-alt');
    }
  }

  // â”€â”€ MISSED OPPORTUNITIES â”€â”€
  if (!h.captures) {
    const caps = getBracketingMoves(sb);
    if (caps.length) {
      const best = caps.sort((a,b)=>b.captures-a.captures)[0];
      const wasThisMove = best.move.src[0]===h.src[0] && best.move.src[1]===h.src[1];
      if (!wasThisMove) {
        addCoachMsg({type:'warn', text:`âš  MISSED CAPTURE: ${pName} had a capturing move available (${formatCoord(best.move.src)} â†’ ${formatCoord(best.move.dst)}) but didn't take it. In Latrunculi, captures should generally be prioritized â€” each piece lost is a loss of mobility and material.`});
      }
    }
  }

  // â”€â”€ MOBILITY CONTEXT â”€â”€
  const myMob  = legalMoves(sb, h.player).length;
  const oppMob = legalMoves(sb, opponent(h.player)).length;
  if (myMob - oppMob > 6) {
    addCoachMsg({type:'good', text:`ğŸ“Š Mobility advantage: ${pName} had ${myMob} legal moves vs opponent's ${oppMob} â€” a strong positional edge before this move.`});
  } else if (oppMob - myMob > 6) {
    addCoachMsg({type:'warn', text:`ğŸ“Š Mobility deficit: ${pName} had only ${myMob} legal moves vs opponent's ${oppMob}. Low mobility often precedes material loss â€” focus on opening escape routes.`});
  }

  // â”€â”€ PRINCIPLE REMINDER â”€â”€
  const principles = [
    { cond: h.captures >= 2,       msg: `Principle: ${PRINCIPLES.fork}` },
    { cond: h.walkedInDanger,      msg: `Principle: ${PRINCIPLES.dangerSquare}` },
    { cond: h.captures === 1,      msg: `Principle: ${PRINCIPLES.captureGeometry}` },
    { cond: myMob < 6,             msg: `Principle: ${PRINCIPLES.endgame}` },
  ];
  const match = principles.find(p => p.cond);
  if (match) addCoachMsg({type:'lesson', text: match.msg});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INTERACTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onCellClick(r, c) {
  if (animating) return;
  if (gameOver) return;
  if (mode === 'puzzle' && puzzleSolved) return;
  if (state.toMove === aiSide && (mode === 'spar' || mode === 'hint')) return; // AI's turn

  const board = state.board;

  if (selected) {
    const isTarget = legalCache.some(m => m.dst[0]===r && m.dst[1]===c);
    if (isTarget) {
      // Check hint before committing
      if (mode==='hint') {
        const h = analyzeHint(state, selected, [r,c]);
        if (h) addCoachMsg(h);
      }
      doMove(selected, [r,c]);
      return;
    }
    // clicking own piece: reselect
    if (board[r][c] === state.toMove) {
      selected = [r,c];
      legalCache = legalMoves(state, state.toMove).filter(m => m.src[0]===r && m.src[1]===c);
      renderState();
      return;
    }
    selected = null;
    legalCache = [];
    renderState();
    return;
  }

  if (board[r][c] === state.toMove) {
    selected = [r,c];
    legalCache = legalMoves(state, state.toMove).filter(m => m.src[0]===r && m.src[1]===c);
    renderState();
  }
}

function doMove(src, dst) {
  if (animating) return;
  const player = state.toMove;
  const stateBefore = { board: cloneBoard(state.board), toMove: state.toMove };
  const moveObj = {src, dst};

  const {state: ns, captures} = applyMove(state, moveObj);

  // Check if destination is now in danger
  const dangerAfterNew = getDangerSquares(ns, player);
  const walkedInDanger = dangerAfterNew.has(dst[0]+','+dst[1]);

  // Puzzle mode check (before committing state)
  const puzzleResult = {state: ns, captures};

  // Find captured squares for animation
  const capSquares = [];
  for (let r=0;r<SIZE;r++)
    for (let c=0;c<SIZE;c++)
      if (stateBefore.board[r][c]===opponent(player) && ns.board[r][c]===EMPTY)
        capSquares.push([r,c]);

  // Hide the source piece immediately (ghost replaces it)
  const srcCell = document.getElementById(`cell-${src[0]}-${src[1]}`);
  const srcPiece = srcCell ? srcCell.querySelector('.piece') : null;
  if (srcPiece) srcPiece.style.visibility = 'hidden';

  selected = null;
  legalCache = [];

  // Play move sound
  playMoveSound();

  // Animate the slide
  const pieceClass = player === WHITE ? 'white' : 'black';
  animateSlide(src, dst, pieceClass, () => {
    // Commit state after animation completes
    stateHistory.push(stateBefore);
    history.push({player, src, dst, captures, walkedInDanger, stateBefore});
    totalCaps += captures;
    moveNum++;
    state = ns;

    // Draw move arrow
    drawMoveArrow(src, dst);

    addHistory(player, src, dst, captures);
    renderState();

    // Capture effects
    if (captures > 0) {
      playCaptureSound(captures);
      capSquares.forEach(([r,c]) => spawnCaptureBurst(r, c, opponent(player)));
      if (captures >= 2) shakeBoard();
    }

    // Puzzle mode validation
    if (mode === 'puzzle') {
      checkPuzzleSolution(moveObj, puzzleResult);
      return; // don't do AI or coach in puzzle mode
    }

    // Coach analysis for hint/learn modes
    if (mode === 'hint' || mode === 'learn') {
      const msgs = coachTurnAnalysis(state);
      msgs.forEach(m => addCoachMsg(m));
      if (!msgs.length && mode==='hint') {
        addCoachMsg({type:'info', text:'Position looks balanced. Think ahead 2 moves.'});
      }
    }

    // Check win
    const w = winner(state);
    if (w !== null) {
      endGame(w);
      return;
    }

    // AI turn
    if (state.toMove === aiSide && (mode==='spar'||mode==='hint')) {
      setTimeout(doAIMove, 400);
    }
  });
}

function doAIMove() {
  if (gameOver || animating) return;
  const bar = document.getElementById('thinking-bar');
  bar.classList.add('active');
  setTimeout(() => {
    const move = chooseMove(state, aiDepth);
    bar.classList.remove('active');
    if (!move) { endGame(opponent(state.toMove)); return; }
    doMove(move.src, move.dst);
  }, 50);
}

function endGame(w) {
  gameOver = true;
  playVictorySound();
  renderState();
  const events = generateReview(history);
  reviewLog = events;

  const title = w === WHITE ? 'White Victorious!' : 'Black Victorious!';
  const sub   = w === (aiSide===WHITE?WHITE:BLACK) && mode==='spar'
    ? 'The AI has defeated you. Study the review to improve.'
    : w === WHITE ? 'The golden legions triumph!' : 'The scarlet forces prevail!';

  document.getElementById('win-title').textContent = title;
  document.getElementById('win-sub').textContent   = sub;
  document.getElementById('stat-turns').textContent = moveNum;
  document.getElementById('stat-caps').textContent  = totalCaps;
  document.getElementById('stat-w').textContent     = countPieces(state.board, WHITE);
  document.getElementById('stat-b').textContent     = countPieces(state.board, BLACK);

  // Postgame review
  const rev = document.getElementById('postgame-review');
  if (events.length) {
    rev.innerHTML = '<div style="font-family:Cinzel,serif;font-size:11px;letter-spacing:0.2em;color:var(--gold-dim);margin-bottom:10px;text-transform:uppercase">Notable Moments</div>';
    events.forEach(e => {
      const d = document.createElement('div');
      d.className = `review-event ${e.type}`;
      d.textContent = e.msg;
      rev.appendChild(d);
    });
  } else {
    rev.innerHTML = '';
  }

  document.getElementById('win-overlay').classList.remove('hidden');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MODES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const LESSONS = [
  {
    title: 'Lesson 1: Capture Geometry',
    body:  'Custodial capture: place two of your pieces on opposite sides of an enemy orthogonally (N/S or E/W). That enemy piece is removed. You cannot capture diagonally.'
  },
  {
    title: 'Lesson 2: Danger Squares',
    body:  'A piece is "hot" if an enemy can sandwich it next turn. In Hint mode, hot squares glow red. Never advance into a bracket without a retreat path.'
  },
  {
    title: 'Lesson 3: Forks',
    body:  'A fork is a move that threatens two captures simultaneously. Your opponent can only block one. Look for moves where your piece lands between two enemy clusters.'
  },
  {
    title: 'Lesson 4: Gates & Net-Building',
    body:  'Two friendly pieces side-by-side form a gate that blocks escape. Build long lines to funnel the enemy into capture zones. Limit their moves before striking.'
  },
  {
    title: 'Lesson 5: Tempo & Mobility',
    body:  'Count your legal moves vs. theirs. More moves = more options. Pressure the enemy into low-mobility positions â€” a piece with no moves is as good as captured.'
  },
  {
    title: 'Lesson 6: Endgame Technique',
    body:  'In the endgame: reduce mobility first, then herd remaining pieces, then convert to forced captures. Piece exhaustion or total immobility both win the game.'
  },
];

function buildLessons() {
  const area = document.getElementById('lessons-area');
  area.innerHTML = '';
  LESSONS.forEach((l, i) => {
    const d = document.createElement('div');
    d.className = 'lesson-step';
    d.dataset.num = i+1;
    d.innerHTML = `<div class="lesson-title">${l.title}</div><div class="lesson-body">${l.body}</div>`;
    d.addEventListener('click', () => {
      document.querySelectorAll('.lesson-step').forEach(x => x.classList.remove('active'));
      d.classList.add('active');
    });
    area.appendChild(d);
  });
}

function setMode(m) {
  mode = m;
  puzzleActive = (m === 'puzzle');
  document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode===m));

  const diffCard    = document.getElementById('diff-card');
  const coachCard   = document.getElementById('coach-card');
  const lessonsCard = document.getElementById('lessons-card');
  const puzzleCard  = document.getElementById('puzzle-card');

  diffCard.style.display    = (m==='spar'||m==='hint') ? '' : 'none';
  lessonsCard.style.display = (m==='learn') ? '' : 'none';
  puzzleCard.style.display  = (m==='puzzle') ? '' : 'none';

  clearCoach();
  if (m==='learn') {
    addCoachMsg({type:'lesson', text:'Select a lesson below to read the principle. Play in any mode to practice.'});
    buildLessons();
  } else if (m==='hint') {
    addCoachMsg({type:'info', text:'Hint mode active. Danger squares glow red. Coach will warn before risky moves.'});
    renderState(); // re-render to show danger squares
  } else if (m==='spar') {
    addCoachMsg({type:'info', text:`Playing vs AI at depth ${aiDepth}. You play ${aiSide === BLACK ? 'White' : 'Black'}.`});
  } else if (m==='puzzle') {
    loadPuzzle(currentPuzzle);
  } else if (m==='explain') {
    explainActive = null;
    refreshHistoryClickable();
    if (history.length === 0) {
      addCoachMsg({type:'info', text:'Play some moves first, then click any move in the history list to get a full breakdown.'});
    } else {
      addCoachMsg({type:'info', text:`${history.length} moves recorded. Click any move in the history list below to see what happened and why.`});
      addCoachMsg({type:'lesson', text:'ğŸ”µ Blue = piece origin  ğŸŸ¢ Green = destination  ğŸ”´ Red = captured  ğŸŸ¡ Gold = engine suggestion'});
    }
  } else if (m==='review') {
    addCoachMsg({type:'info', text:'Finish a game first, then return here to review the key moments.'});
    reviewLog.forEach(e => addCoachMsg({type: e.type==='blunder'?'warn': e.type==='good'?'good':'info', text: e.msg}));
  }

  document.getElementById('coach-title').textContent =
    m==='spar'    ? 'Battle Log' :
    m==='hint'    ? 'Coach' :
    m==='learn'   ? 'Tutor' :
    m==='puzzle'  ? 'Puzzle Coach' :
    m==='explain' ? 'Move Explainer' :
                    'After-Action Review';
}

function setDepth(d) {
  aiDepth = d;
  document.querySelectorAll('.diff-btn').forEach(b => b.classList.toggle('active', +b.dataset.d===d));
  clearCoach();
  const names = {1:'Novice',2:'Soldier',3:'Tribune',4:'Praetor'};
  addCoachMsg({type:'info', text:`Difficulty set to ${names[d]}. ${d>=3?'The AI will now plan several moves ahead â€” beware!':''}`});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function newGame() {
  if (mode === 'puzzle') { loadPuzzle(currentPuzzle); return; }
  state    = makeState(initialBoard(), WHITE);
  selected = null;
  legalCache = [];
  gameOver   = false;
  history    = [];
  stateHistory = [];
  reviewLog  = [];
  explainActive = null;
  moveNum    = 0;
  totalCaps  = 0;
  clearMoveArrow();
  document.getElementById('win-overlay').classList.add('hidden');
  document.getElementById('history-list').innerHTML = '';
  clearCoach();
  addCoachMsg({type:'info', text:'A new battle begins. White moves first.'});
  if (mode==='hint') addCoachMsg({type:'lesson', text:PRINCIPLES.captureGeometry});
  renderState();
  // If AI plays White:
  if (state.toMove === aiSide && (mode==='spar'||mode==='hint')) setTimeout(doAIMove, 600);
}

function resign() {
  if (gameOver) return;
  const loser = state.toMove;
  const w     = opponent(loser);
  endGame(w);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SOUND ENGINE (Web Audio API â€” no external files)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let audioCtx = null;
function getAudioCtx() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return audioCtx;
}

function playMoveSound() {
  try {
    const ctx = getAudioCtx();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(440, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(280, ctx.currentTime + 0.08);
    gain.gain.setValueAtTime(0.12, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.12);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.12);
  } catch(e) {}
}

function playCaptureSound(count) {
  try {
    const ctx = getAudioCtx();
    // metallic clang
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(600 + count * 200, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.25);
    gain.gain.setValueAtTime(0.15, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.25);
    osc.connect(gain); gain.connect(ctx.destination);
    osc.start(ctx.currentTime); osc.stop(ctx.currentTime + 0.25);
    // impact noise burst
    const bufSize = ctx.sampleRate * 0.06;
    const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i/bufSize);
    const noise = ctx.createBufferSource();
    noise.buffer = buf;
    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.08 * count, ctx.currentTime);
    ng.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.06);
    noise.connect(ng); ng.connect(ctx.destination);
    noise.start(ctx.currentTime); noise.stop(ctx.currentTime + 0.06);
  } catch(e) {}
}

function playVictorySound() {
  try {
    const ctx = getAudioCtx();
    const notes = [523.25, 659.25, 783.99, 1046.5]; // C5 E5 G5 C6
    notes.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.12);
      gain.gain.setValueAtTime(0, ctx.currentTime + i * 0.12);
      gain.gain.linearRampToValueAtTime(0.12, ctx.currentTime + i * 0.12 + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.12 + 0.4);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(ctx.currentTime + i * 0.12);
      osc.stop(ctx.currentTime + i * 0.12 + 0.4);
    });
  } catch(e) {}
}

function playPuzzleSolvedSound() {
  try {
    const ctx = getAudioCtx();
    const notes = [392, 493.88, 587.33]; // G4 B4 D5
    notes.forEach((freq, i) => {
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.1);
      gain.gain.setValueAtTime(0, ctx.currentTime + i * 0.1);
      gain.gain.linearRampToValueAtTime(0.1, ctx.currentTime + i * 0.1 + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.1 + 0.3);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(ctx.currentTime + i * 0.1);
      osc.stop(ctx.currentTime + i * 0.1 + 0.3);
    });
  } catch(e) {}
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ANIMATION ENGINE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let animating = false;

function getCellCenter(r, c) {
  const cell = document.getElementById(`cell-${r}-${c}`);
  if (!cell) return {x:0,y:0};
  const rect = cell.getBoundingClientRect();
  return { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
}

function getCellOffset(r, c) {
  const cell = document.getElementById(`cell-${r}-${c}`);
  if (!cell) return {x:0,y:0};
  return { x: cell.offsetLeft, y: cell.offsetTop };
}

function animateSlide(src, dst, pieceClass, callback) {
  animating = true;
  const boardEl = document.getElementById('board');
  const sqSize = boardEl.querySelector('.cell').offsetWidth;

  const ghost = document.createElement('div');
  ghost.className = `piece-ghost ${pieceClass}`;

  const srcOff = getCellOffset(src[0], src[1]);
  const dstOff = getCellOffset(dst[0], dst[1]);

  const centerOff = (sqSize - 52) / 2;
  ghost.style.position = 'absolute';
  ghost.style.left = (srcOff.x + centerOff) + 'px';
  ghost.style.top = (srcOff.y + centerOff) + 'px';
  ghost.style.transform = 'translate(0,0)';

  boardEl.appendChild(ghost);

  // force reflow
  ghost.offsetWidth;

  const dx = dstOff.x - srcOff.x;
  const dy = dstOff.y - srcOff.y;
  ghost.style.transform = `translate(${dx}px, ${dy}px)`;

  ghost.addEventListener('transitionend', () => {
    ghost.remove();
    animating = false;
    if (callback) callback();
  }, {once: true});

  // fallback timeout in case transitionend doesn't fire
  setTimeout(() => {
    if (ghost.parentNode) { ghost.remove(); animating = false; if (callback) callback(); }
  }, 350);
}

function spawnCaptureBurst(r, c, color) {
  const cell = document.getElementById(`cell-${r}-${c}`);
  if (!cell) return;
  const burst = document.createElement('div');
  burst.className = 'capture-burst';

  const particleCount = 12;
  const colors = color === WHITE ? ['gold','ember','gold'] : ['red','ember','red'];
  for (let i = 0; i < particleCount; i++) {
    const p = document.createElement('div');
    const angle = (Math.PI * 2 / particleCount) * i + (Math.random() - 0.5) * 0.4;
    const dist = 20 + Math.random() * 25;
    p.className = 'burst-particle ' + colors[i % colors.length];
    p.style.setProperty('--bx', Math.cos(angle) * dist + 'px');
    p.style.setProperty('--by', Math.sin(angle) * dist + 'px');
    p.style.animationDelay = (Math.random() * 0.05) + 's';
    burst.appendChild(p);
  }

  // flash
  const flash = document.createElement('div');
  flash.className = 'capture-flash';
  cell.appendChild(flash);
  cell.appendChild(burst);

  setTimeout(() => { burst.remove(); flash.remove(); }, 600);
}

function shakeBoard() {
  const container = document.querySelector('.board-container');
  container.classList.remove('board-shake');
  container.offsetWidth; // force reflow
  container.classList.add('board-shake');
  container.addEventListener('animationend', () => container.classList.remove('board-shake'), {once:true});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MOVE ARROW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let lastMoveArrow = null; // {src, dst}

function drawMoveArrow(src, dst) {
  lastMoveArrow = {src, dst};
  const svg = document.getElementById('move-arrow');
  if (!svg) return;
  const boardEl = document.getElementById('board');
  const sqSize = boardEl.querySelector('.cell').offsetWidth;
  const coordsTop = document.getElementById('coords-top');
  const topOffset = coordsTop ? coordsTop.offsetHeight : 0;

  svg.style.top = topOffset + 'px';
  svg.style.width = (sqSize * SIZE) + 'px';
  svg.style.height = (sqSize * SIZE) + 'px';

  const x1 = src[1] * sqSize + sqSize/2;
  const y1 = src[0] * sqSize + sqSize/2;
  const x2 = dst[1] * sqSize + sqSize/2;
  const y2 = dst[0] * sqSize + sqSize/2;

  // shorten by 8px at the end so arrowhead sits cleanly
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.sqrt(dx*dx+dy*dy);
  const ux = dx/len, uy = dy/len;
  const ex = x2 - ux*12, ey = y2 - uy*12;

  // arrowhead
  const headSize = 8;
  const px = ux*headSize, py = uy*headSize;
  const ax = x2 - px + py*0.6, ay = y2 - py - px*0.6;
  const bx = x2 - px - py*0.6, by = y2 - py + px*0.6;

  svg.innerHTML = `
    <line x1="${x1}" y1="${y1}" x2="${ex}" y2="${ey}"
          stroke="rgba(201,162,39,0.55)" stroke-width="3" stroke-linecap="round"/>
    <polygon points="${x2},${y2} ${ax},${ay} ${bx},${by}"
             fill="rgba(201,162,39,0.7)"/>
  `;
}

function clearMoveArrow() {
  lastMoveArrow = null;
  const svg = document.getElementById('move-arrow');
  if (svg) svg.innerHTML = '';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  UNDO MOVE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function undoMove() {
  if (gameOver || mode === 'puzzle') return;
  if (history.length === 0) return;

  // In spar/hint modes, undo both player and AI moves
  let undoCount = 1;
  if ((mode === 'spar' || mode === 'hint') && history.length >= 2) {
    undoCount = 2; // undo AI move + player move
  }

  for (let i = 0; i < undoCount && history.length > 0; i++) {
    const last = history.pop();
    stateHistory.pop();
    totalCaps -= last.captures;
    moveNum--;
  }

  // Restore state
  if (stateHistory.length > 0) {
    const lastState = history[history.length - 1];
    state = lastState ? applyMove(lastState.stateBefore, {src: lastState.src, dst: lastState.dst}).state : makeState(initialBoard(), WHITE);
  } else {
    state = makeState(initialBoard(), WHITE);
  }

  selected = null;
  legalCache = [];
  clearMoveArrow();

  // Rebuild history display
  document.getElementById('history-list').innerHTML = '';
  for (let i = 0; i < history.length; i++) {
    const h = history[i];
    addHistoryEntry(h.player, h.src, h.dst, h.captures, i);
  }

  renderState();
  addCoachMsg({type:'info', text:'Move undone.'});
}

// Separate history rendering from history recording
function addHistoryEntry(player, src, dst, caps, idx) {
  const h = document.getElementById('history-list');
  if (idx % 2 === 0) {
    const pair = Math.floor(idx / 2) + 1;
    const row = document.createElement('div');
    row.className = 'history-item';
    row.id = `hrow-${idx}`;
    row.dataset.idx = idx;
    row.innerHTML = `<span class="h-num">${pair}.</span><span class="h-${player.toLowerCase()}">${formatCoord(src)}â†’${formatCoord(dst)}${caps?` Ã—${caps}`:''}</span>`;
    row.addEventListener('click', () => onHistoryClick(idx, row));
    h.appendChild(row);
  } else {
    const prevRow = document.getElementById(`hrow-${idx-1}`);
    if (prevRow) {
      const sp = document.createElement('span');
      sp.className = `h-${player.toLowerCase()}`;
      sp.style.cursor = 'pointer';
      sp.textContent = ` ${formatCoord(src)}â†’${formatCoord(dst)}${caps?` Ã—${caps}`:''}`;
      sp.dataset.idx = idx;
      sp.addEventListener('click', (e) => { e.stopPropagation(); onHistoryClick(idx, prevRow); });
      prevRow.appendChild(sp);
    }
  }
  h.scrollTop = h.scrollHeight;
  refreshHistoryClickable();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CHOOSE SIDE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function setPlayerSide(s) {
  const playerSide = s;
  aiSide = opponent(playerSide);
  document.querySelectorAll('.side-btn').forEach(b => b.classList.toggle('active', b.dataset.s === s));
  newGame();
  addCoachMsg({type:'info', text:`You are now playing as ${playerSide === WHITE ? 'White' : 'Black'}.`});
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PUZZLE MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const PUZZLES = [
  {
    // W at (2,2) anchor, B at (2,3), W at (2,7) slides left to (2,4) to sandwich B
    title: 'Puzzle 1: First Blood',
    objective: 'Capture the black piece in one move. Complete the sandwich!',
    board: [
      '........',
      '........',
      '..WB...W',
      '........',
      '........',
      '........',
      '........',
      '........',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      return result.captures >= 1;
    }
  },
  {
    // W at (3,4) anchor north, B at (4,4), W at (7,4) slides up to (5,4) to sandwich B
    title: 'Puzzle 2: The Sandwich',
    objective: 'Complete the vertical sandwich to capture the black piece.',
    board: [
      '........',
      '........',
      '........',
      '....W...',
      '....B...',
      '........',
      '........',
      '....W...',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      return result.captures >= 1;
    }
  },
  {
    // W anchors at (1,3) and (5,3). B targets at (2,3) and (4,3). W at (3,0) slides to (3,3) for fork
    title: 'Puzzle 3: Double Strike',
    objective: 'Find the fork â€” capture 2 pieces in a single move!',
    board: [
      '........',
      '...W....',
      '...B....',
      'W.......',
      '...B....',
      '...W....',
      '........',
      '........',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      return result.captures >= 2;
    }
  },
  {
    // B at (2,3) and (5,3) threaten W at (4,3). B at (2,3) can move to (3,3) to capture.
    title: 'Puzzle 4: Avoid the Trap',
    objective: 'Your piece at d4 is in danger! Move it somewhere safe.',
    board: [
      '........',
      '........',
      '...B....',
      '........',
      '...W....',
      '...B....',
      '........',
      '........',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      if (move.src[0] !== 4 || move.src[1] !== 3) return false;
      const dangerAfter = getDangerSquares(result.state, WHITE);
      return !dangerAfter.has(move.dst[0]+','+move.dst[1]);
    }
  },
  {
    // W anchors at (1,3),(5,3),(3,5). B targets at (2,3),(4,3),(3,4). W at (3,0) to (3,3) for triple
    title: 'Puzzle 5: Triple Threat',
    objective: 'Find the devastating move that captures 3 pieces at once.',
    board: [
      '........',
      '...W....',
      '...B....',
      'W...BW..',
      '...B....',
      '...W....',
      '........',
      '........',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      return result.captures >= 3;
    }
  },
  {
    // B at (5,1). W walls at (4,1) and (6,1). W at (5,4) slides left to (5,2) to cage B
    title: 'Puzzle 6: Herding',
    objective: 'Cage the black piece â€” reduce its mobility below 3 moves.',
    board: [
      '........',
      '........',
      '........',
      '........',
      '.W......',
      '.B..W...',
      '.W......',
      '........',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      const blackMoves = legalMoves(result.state, BLACK);
      return blackMoves.length < 3;
    }
  },
  {
    // B at (2,3) and (5,3) threaten W at (3,3). Must move W at (3,3) to safety.
    title: 'Puzzle 7: Escape Artist',
    objective: 'Your piece at d5 is about to be captured! Escape to safety.',
    board: [
      '........',
      '........',
      '...B....',
      '...W....',
      '........',
      '...B....',
      '........',
      '........',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      if (move.src[0] !== 3 || move.src[1] !== 3) return false;
      const dangerAfter = getDangerSquares(result.state, WHITE);
      return !dangerAfter.has(move.dst[0]+','+move.dst[1]);
    }
  },
  {
    title: 'Puzzle 8: Wall of Death',
    objective: 'Seal the gate â€” trap and capture the black piece in the corner.',
    board: [
      '........',
      '........',
      '........',
      '........',
      '........',
      'W.......',
      'BW......',
      '.W......',
    ],
    toMove: WHITE,
    validate: function(st, move, result) {
      const blackMoves = legalMoves(result.state, BLACK);
      return blackMoves.length === 0 || result.captures >= 1;
    }
  },
];

let currentPuzzle = 0;
let puzzleActive = false;
let puzzleSolved = false;

function parsePuzzleBoard(lines) {
  const board = [];
  for (const line of lines) {
    const row = [];
    for (const ch of line) {
      if (ch === 'W') row.push(WHITE);
      else if (ch === 'B') row.push(BLACK);
      else row.push(EMPTY);
    }
    board.push(row);
  }
  return board;
}

function loadPuzzle(idx) {
  if (idx < 0 || idx >= PUZZLES.length) return;
  currentPuzzle = idx;
  puzzleActive = true;
  puzzleSolved = false;
  const p = PUZZLES[idx];

  state = makeState(parsePuzzleBoard(p.board), p.toMove);
  selected = null;
  legalCache = [];
  gameOver = false;
  history = [];
  stateHistory = [];
  moveNum = 0;
  totalCaps = 0;
  clearMoveArrow();

  document.getElementById('puzzle-title').textContent = p.title;
  document.getElementById('puzzle-objective').textContent = p.objective;
  document.getElementById('puzzle-feedback').innerHTML = '';
  document.getElementById('puzzle-progress').textContent = `${idx + 1} / ${PUZZLES.length}`;
  document.getElementById('puzzle-prev').disabled = idx === 0;
  document.getElementById('puzzle-next').disabled = idx === PUZZLES.length - 1;
  document.getElementById('history-list').innerHTML = '';
  document.getElementById('win-overlay').classList.add('hidden');

  clearCoach();
  addCoachMsg({type:'lesson', text: p.objective});

  renderState();
}

function puzzleNav(dir) {
  const next = currentPuzzle + dir;
  if (next >= 0 && next < PUZZLES.length) loadPuzzle(next);
}

function checkPuzzleSolution(move, result) {
  if (!puzzleActive || puzzleSolved) return;
  const p = PUZZLES[currentPuzzle];
  if (p.validate(state, move, result)) {
    puzzleSolved = true;
    playPuzzleSolvedSound();
    document.getElementById('puzzle-feedback').innerHTML = '<div class="puzzle-solved">Solved! Well done, Legionary.</div>';
    addCoachMsg({type:'good', text:'Correct! You found the right move.'});
  } else {
    addCoachMsg({type:'warn', text:'Not quite â€” try again. Click Reset to retry.'});
    // auto-reset after a moment
    setTimeout(() => { if (!puzzleSolved) loadPuzzle(currentPuzzle); }, 1200);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
buildBoard();
newGame();
setMode('spar');
</script>
</body>
</html>
